{
  "version": 3,
  "sources": ["../../../src/style/createHash.ts", "../../../src/style/cssParser.ts", "../../../src/style/createStyleElement.ts", "../../../src/style/css.ts"],
  "sourcesContent": ["/**\n * Gera um hash \u00FAnico baseado no algoritmo DJB2.\n * @param str - O conte\u00FAdo a partir do qual o hash ser\u00E1 gerado.\n * @returns O hash gerado como uma string.\n */\nexport const createHash = (text: string, selector: string): string => {\n  let hash = 5381;\n  for (let i = 0; i < text.length; i++) {\n    hash = (hash * 33) ^ text.charCodeAt(i);\n  }\n  return `${selector}-${(hash >>> 0).toString(36)}`;\n};\n", "type WrapStyleParams = {\n  style: string;\n  selector: string;\n};\n\ntype Accumulator = {\n  insideBlock: number;\n  globalRules: string;\n  result: string;\n};\n\ntype LineProcessing = {\n  globalRules: string;\n  result: string;\n};\n\nconst wrapLooseRulesOutsideMediaQuery = ({\n  style,\n  selector,\n}: WrapStyleParams): string => {\n  const lines = style.split(\"\\n\");\n  const ruleRegex = /^\\s*([\\w-]+)\\s*:\\s*[^;]+;/;\n\n  const initialState: Accumulator = {\n    insideBlock: 0,\n    globalRules: \"\",\n    result: \"\",\n  };\n\n  const processGlobalRules = (\n    globalRules: string,\n    result: string,\n    selector: string,\n  ): LineProcessing => ({\n    globalRules: \"\",\n    result: `${result}${selector} {\\n${globalRules}}\\n\\n`,\n  });\n\n  const processRegularLine = (\n    line: string,\n    result: string,\n  ): LineProcessing => ({\n    globalRules: \"\",\n    result: `${result}${line}\\n`,\n  });\n\n  const addGlobalRule = (\n    line: string,\n    globalRules: string,\n  ): LineProcessing => ({\n    globalRules: `${globalRules}${line}\\n`,\n    result: \"\",\n  });\n\n  const countBlocks = (line: string): number => {\n    const openings = (line.match(/{/g) || []).length;\n    const closings = (line.match(/}/g) || []).length;\n    return openings - closings;\n  };\n\n  const processLine = (acc: Accumulator, line: string): Accumulator => {\n    acc.insideBlock += countBlocks(line);\n\n    // Case 1: Line is a global rule\n    if (acc.insideBlock === 0 && ruleRegex.test(line)) {\n      const { globalRules, result } = addGlobalRule(line, acc.globalRules);\n      return { ...acc, globalRules, result: acc.result + result };\n    }\n\n    // Case 2: There are accumulated global rules\n    if (acc.globalRules) {\n      const { globalRules, result } = processGlobalRules(\n        acc.globalRules,\n        acc.result,\n        selector,\n      );\n      const processedLine = processRegularLine(line, \"\");\n      return {\n        ...acc,\n        globalRules,\n        result: result + processedLine.result,\n      };\n    }\n\n    // Case 3: Regular line\n    const { globalRules, result } = processRegularLine(line, acc.result);\n    return { ...acc, globalRules, result };\n  };\n\n  const { result, globalRules } = lines.reduce(processLine, initialState);\n\n  return globalRules\n    ? `${result}${selector} {\\n${globalRules}}\\n`.trim()\n    : result.trim();\n};\n\nconst wrapLooseRulesInsideMediaQuery = ({\n  style,\n  selector,\n}: WrapStyleParams): string => {\n  const regex = /@media\\s*([^{]+)\\s*\\{([\\s\\S]*?)\\}/g;\n  const ruleRegex = /^\\s*([\\w-]+)\\s*:\\s*[^;]+;/;\n\n  return style.replace(regex, (match, mediaQuery, innerCss) => {\n    const rules = innerCss\n      .trim()\n      .split(\"\\n\")\n      .map((line: string) => line.trim())\n      .filter((line: string) => line);\n\n    const wrappedRules = rules\n      .filter((rule: string) => ruleRegex.test(rule))\n      .map((rule: string) => `${selector} {\\n${rule.trim()}\\n}`)\n      .join(\"\\n\");\n\n    return `@media ${mediaQuery.trim()} {\\n${wrappedRules}\\n}`;\n  });\n};\n\nconst applyClassNameScope = ({ style, selector }: WrapStyleParams): string => {\n  const regex = /\\.(\\w+)/g;\n  return style.replace(regex, `.${selector}_$1`);\n};\n\nexport const transformStyle = (rawStyle: string, selector: string): string => {\n  let style = rawStyle;\n  const className = `.${selector}`;\n  style = applyClassNameScope({ style, selector });\n  style = wrapLooseRulesOutsideMediaQuery({ style, selector: className });\n  style = wrapLooseRulesInsideMediaQuery({ style, selector: className });\n\n  return style;\n};\n", "const styleElementCache: Map<string, HTMLStyleElement> = new Map();\n\nexport const createStyleElement = (componentId: string): HTMLStyleElement => {\n  const styleElement = styleElementCache.get(componentId);\n\n  if (styleElement !== undefined) {\n    return styleElement;\n  }\n\n  const style = document.createElement(\"style\");\n  style.setAttribute(\"data-component\", componentId);\n  document.head.appendChild(style);\n  styleElementCache.set(componentId, style);\n\n  return style;\n};\n", "import type { TaggedStyle } from \"./types\";\nimport { createHash } from \"./createHash\";\nimport { transformStyle } from \"./cssParser\";\nimport { createStyleElement } from \"./createStyleElement\";\n\ntype HandlerParams = {\n  hashId: string;\n  scopedStyle: string;\n  styleElement: Element;\n};\ntype Handler = (payload: HandlerParams) => void;\n\nconst cssCache: Map<string, string> = new Map();\n\nexport const css =\n  (selector: string, handler: Handler = () => {}): TaggedStyle =>\n  (\n    strings: TemplateStringsArray,\n    ...interpolations: (string | number)[]\n  ): string => {\n    const rawCSS = strings.reduce(\n      (accumulator, str, index) =>\n        `${accumulator}${str}${interpolations[index] !== undefined ? interpolations[index] : \"\"}`,\n      \"\",\n    );\n\n    const cachedClassName = cssCache.get(rawCSS);\n    if (cachedClassName !== undefined) {\n      return cachedClassName;\n    }\n\n    const hashId = createHash(rawCSS, selector);\n    const scopedStyle = transformStyle(rawCSS, `${hashId}`);\n    const styleElement = createStyleElement(`${hashId}`);\n\n    handler({ hashId, scopedStyle, styleElement });\n\n    if (!styleElement.innerHTML.includes(scopedStyle)) {\n      styleElement.innerHTML += scopedStyle;\n    }\n\n    cssCache.set(rawCSS, hashId);\n\n    return hashId;\n  };\n"],
  "mappings": "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",
  "names": ["createHash", "__name", "text", "selector", "hash", "i", "wrapLooseRulesOutsideMediaQuery", "__name", "style", "selector", "lines", "ruleRegex", "initialState", "processGlobalRules", "globalRules", "result", "processRegularLine", "line", "addGlobalRule", "countBlocks", "openings", "closings", "processLine", "acc", "processedLine", "wrapLooseRulesInsideMediaQuery", "regex", "match", "mediaQuery", "innerCss", "wrappedRules", "rule", "applyClassNameScope", "transformStyle", "rawStyle", "className", "styleElementCache", "createStyleElement", "__name", "componentId", "styleElement", "style", "cssCache", "css", "__name", "selector", "handler", "strings", "interpolations", "rawCSS", "accumulator", "str", "index", "cachedClassName", "hashId", "createHash", "scopedStyle", "transformStyle", "styleElement", "createStyleElement"]
}
