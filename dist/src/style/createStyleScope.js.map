{
  "version": 3,
  "sources": ["../../../src/style/createStyleScope.ts"],
  "sourcesContent": ["// Fun\u00E7\u00E3o para dividir o CSS em regras independentes usando regex\nconst splitIntoRules = (css: string): string[] => {\n  const ruleRegex = /([^{]+)\\{([^}]+)\\}/g;\n  const rules: string[] = []; // Tipagem expl\u00EDcita da lista de regras\n  let match: RegExpExecArray | null; // Tipagem expl\u00EDcita para vari\u00E1vel match\n\n  match = ruleRegex.exec(css);\n  while (match !== null) {\n    const selectorPart = match[1].trim();\n    const declarationsPart = match[2].trim();\n    if (selectorPart && declarationsPart) {\n      rules.push(`${selectorPart} { ${declarationsPart} }`);\n    }\n    match = ruleRegex.exec(css); // Move a chamada para a pr\u00F3xima itera\u00E7\u00E3o aqui\n  }\n\n  return rules;\n};\n\n// Fun\u00E7\u00E3o para analisar CSS e separ\u00E1-lo em seletores e declara\u00E7\u00F5es\nconst parseRule = (rule: string): [string[], string] | null => {\n  const parts = rule.split(\"{\").map((part) => part.trim());\n\n  if (parts.length !== 2) {\n    console.warn(`Regra CSS inv\u00E1lida omitida: \"${rule}\"`);\n    return null;\n  }\n\n  const [selectorsPart, declarationsPart] = parts;\n\n  if (!selectorsPart || !declarationsPart) {\n    console.warn(`Regra CSS incompleta omitida: \"${rule}\"`);\n    return null;\n  }\n\n  const selectors = selectorsPart.split(\",\").map((selector) => selector.trim());\n  const declarations = declarationsPart.trim();\n\n  return [selectors, declarations];\n};\n\nconst replaceClassName = (selector: string, className: string): string => {\n  const regex = /^&/; // Express\u00E3o regular que detecta & no in\u00EDcio do seletor\n  return selector.replace(regex, `.${className}`) || `.${className}`;\n};\n\n// Fun\u00E7\u00E3o para escopar regras dentro de media queries\nconst scopeMediaQueryRules = (rule: string, className: string): string => {\n  return rule.replace(/{([^}]+)}/, (_, groupContent) => {\n    const innerRules = splitIntoRules(groupContent);\n    const scopedInnerContent = innerRules\n      .map((innerRule) => scopeRule(innerRule, className))\n      .filter(Boolean)\n      .join(\" \");\n    return ` { ${scopedInnerContent} }`;\n  });\n};\n\n// Fun\u00E7\u00E3o para escopar regras individuais\nconst scopeRule = (rule: string, className: string): string | null => {\n  const parsedRule = parseRule(rule);\n  if (parsedRule) {\n    const [selectors, declarations] = parsedRule;\n    const scopedSelectors = selectors.map((selector) =>\n      replaceClassName(selector, className),\n    );\n    return `${scopedSelectors.join(\", \")} { ${declarations} }`;\n  }\n  return `.${className} { ${rule.trim()} }`; // Envolve regras sem seletor\n};\n\n// Fun\u00E7\u00E3o principal para escopo do CSS\nexport const createStyleScope = (className: string, css: string): string => {\n  let scopedCSS = \"\";\n\n  const rules = splitIntoRules(css);\n  for (const rule of rules) {\n    if (rule.startsWith(\"@media\")) {\n      // Manipula media queries\n      scopedCSS += `${scopeMediaQueryRules(rule, className)}\\n`;\n    } else {\n      // Para regras gerais\n      const scopedRule = scopeRule(rule, className);\n      if (scopedRule) {\n        scopedCSS += `.${className} { ${scopedRule} }\\n`; // Envolvendo a regra scopoada com a classe\n      }\n    }\n  }\n\n  return scopedCSS.trim();\n};\n"],
  "mappings": "+EACA,IAAMA,EAAiBC,EAACC,GAA0B,CAChD,IAAMC,EAAY,sBACZC,EAAkB,CAAC,EACrBC,EAGJ,IADAA,EAAQF,EAAU,KAAKD,CAAG,EACnBG,IAAU,MAAM,CACrB,IAAMC,EAAeD,EAAM,CAAC,EAAE,KAAK,EAC7BE,EAAmBF,EAAM,CAAC,EAAE,KAAK,EACnCC,GAAgBC,GAClBH,EAAM,KAAK,GAAGE,CAAY,MAAMC,CAAgB,IAAI,EAEtDF,EAAQF,EAAU,KAAKD,CAAG,CAC5B,CAEA,OAAOE,CACT,EAhBuB,kBAmBjBI,EAAYP,EAACQ,GAA4C,CAC7D,IAAMC,EAAQD,EAAK,MAAM,GAAG,EAAE,IAAKE,GAASA,EAAK,KAAK,CAAC,EAEvD,GAAID,EAAM,SAAW,EACnB,eAAQ,KAAK,mCAAgCD,CAAI,GAAG,EAC7C,KAGT,GAAM,CAACG,EAAeL,CAAgB,EAAIG,EAE1C,GAAI,CAACE,GAAiB,CAACL,EACrB,eAAQ,KAAK,kCAAkCE,CAAI,GAAG,EAC/C,KAGT,IAAMI,EAAYD,EAAc,MAAM,GAAG,EAAE,IAAKE,GAAaA,EAAS,KAAK,CAAC,EACtEC,EAAeR,EAAiB,KAAK,EAE3C,MAAO,CAACM,EAAWE,CAAY,CACjC,EAnBkB,aAqBZC,EAAmBf,EAAA,CAACa,EAAkBG,IAA8B,CACxE,IAAMC,EAAQ,KACd,OAAOJ,EAAS,QAAQI,EAAO,IAAID,CAAS,EAAE,GAAK,IAAIA,CAAS,EAClE,EAHyB,oBAMnBE,EAAuBlB,EAAA,CAACQ,EAAcQ,IACnCR,EAAK,QAAQ,YAAa,CAACW,EAAGC,IAM5B,MALYrB,EAAeqB,CAAY,EAE3C,IAAKC,GAAcC,EAAUD,EAAWL,CAAS,CAAC,EAClD,OAAO,OAAO,EACd,KAAK,GAAG,CACoB,IAChC,EAR0B,wBAYvBM,EAAYtB,EAAA,CAACQ,EAAcQ,IAAqC,CACpE,IAAMO,EAAahB,EAAUC,CAAI,EACjC,GAAIe,EAAY,CACd,GAAM,CAACX,EAAWE,CAAY,EAAIS,EAIlC,MAAO,GAHiBX,EAAU,IAAKC,GACrCE,EAAiBF,EAAUG,CAAS,CACtC,EAC0B,KAAK,IAAI,CAAC,MAAMF,CAAY,IACxD,CACA,MAAO,IAAIE,CAAS,MAAMR,EAAK,KAAK,CAAC,IACvC,EAVkB,aAaLgB,EAAmBxB,EAAA,CAACgB,EAAmBf,IAAwB,CAC1E,IAAIwB,EAAY,GAEVtB,EAAQJ,EAAeE,CAAG,EAChC,QAAWO,KAAQL,EACjB,GAAIK,EAAK,WAAW,QAAQ,EAE1BiB,GAAa,GAAGP,EAAqBV,EAAMQ,CAAS,CAAC;AAAA,MAChD,CAEL,IAAMU,EAAaJ,EAAUd,EAAMQ,CAAS,EACxCU,IACFD,GAAa,IAAIT,CAAS,MAAMU,CAAU;AAAA,EAE9C,CAGF,OAAOD,EAAU,KAAK,CACxB,EAlBgC",
  "names": ["splitIntoRules", "__name", "css", "ruleRegex", "rules", "match", "selectorPart", "declarationsPart", "parseRule", "rule", "parts", "part", "selectorsPart", "selectors", "selector", "declarations", "replaceClassName", "className", "regex", "scopeMediaQueryRules", "_", "groupContent", "innerRule", "scopeRule", "parsedRule", "createStyleScope", "scopedCSS", "scopedRule"]
}
